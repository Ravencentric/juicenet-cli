{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> juicenet <p>     CLI tool designed to simplify the process of uploading files to Usenet      </p> </p> <p> </p>"},{"location":"#about-the-project","title":"About The Project","text":"<p>Uploading stuff to Usenet is tedious so I tried to make it easier.</p> <ul> <li>Uses ParPar and Nyuu under the hood</li> <li>Recursively searches for files with pre-defined extensions in <code>juicenet.yaml</code> or as passed in <code>--exts</code></li> <li>Alternatively, searches for glob patterns passed in <code>--glob</code></li> <li>Preserves folder structure without RAR. RAR sucks and here's why</li> <li>Does everything automatically and gives you the resulting <code>nzbs</code> in a neatly sorted manner</li> <li>Offers the option to pick and choose what it does if you don't want it doing everything automatically</li> <li>Automatically checks for and reposts failed articles from last run. Also has the option to not do this</li> <li>Can continue from where it stopped if it gets interrupted for any reason</li> </ul>"},{"location":"#license","title":"License","text":"<p>Distributed under the Unlicense License. See UNLICENSE for more information.</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>Warning</p> <p>This API is considered unstable and might change in the future. If you're using this, pin your install to a specific version</p>"},{"location":"api-reference/#juicenet.juicenet","title":"juicenet","text":"<pre><code>juicenet(\n    path: StrPath,\n    /,\n    *,\n    config: StrPath | JuicenetConfig,\n    public: bool = False,\n    bdmv_naming: bool = False,\n    resume: bool = True,\n    skip_raw: bool = False,\n    debug: bool = False,\n) -&gt; JuiceBox\n</code></pre> <p>Upload a file or folder to usenet. This will always produce one NZB for one input.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>The path to an existing file. This can either be a string representing the path or a pathlib.Path object.</p> required <code>config</code> <code>str or Path or JuicenetConfig</code> <p>The configuration to use when processing the file or directory. This can either be a string representing the path to a YAML configuration file, a <code>pathlib.Path</code> object pointing to a YAML configuration file, or a <code>juicenet.JuicenetConfig</code> dataclass.</p> required <code>public</code> <code>bool</code> <p>Whether the upload is meant to be public or not. Uses the public config if specified, falls back to using the private one if not. Default is False.</p> <code>False</code> <code>bdmv_naming</code> <code>bool</code> <p>Whether to use an alternate naming for BDMVs. This will try to fix the awful BDMV disc naming in some cases, i.e, if you pass <code>/BDMVs/Big Buck Bunny [Vol.1]/DISC_01</code>, then the resulting NZB will be renamed to <code>Big Buck Bunny [Vol.1]_DISC_01.nzb</code> instead of <code>DISC_01.nzb</code>. Recommended if your input is a BDMV disc and you're uncertain about how they are named. Keep it <code>False</code> if you're certain that your BDMV discs are named appropriately. Only works on directory input, does nothing (i.e, <code>False</code>) if your input is a file.</p> <code>False</code> <code>resume</code> <code>bool</code> <p>Whether to enable resumability. Files uploaded by previous runs will be skipped if True. Default is True.</p> <code>True</code> <code>skip_raw</code> <code>bool</code> <p>Skip checking and reposting failed raw articles. Default is False.</p> <code>False</code> <code>debug</code> <code>bool</code> <p>Whether to enable debug logs. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>JuiceBox</code> <p>Dataclass used to represent the output of Juicenet.</p> <p>Raises:</p> Type Description <code>JuicenetInputError</code> <p>Invalid input.</p> Notes <ul> <li> <p>You should never upload an entire directory consisting of several files as a single NZB.   Use <code>juicenet.get_files</code> or <code>juicenet.get_glob_matches</code> to first get the relevant files and   then pass each one to juicenet.</p> </li> <li> <p>You should never upload an entire BDMV consisting of several discs as a single NZB.   Use <code>juicenet.get_bdmv_discs</code> to first get each individual disc and then pass each one to juicenet.</p> </li> </ul> <p>Examples:</p> <pre><code>from pathlib import Path\n\nfrom juicenet import JuicenetConfig, juicenet\n\nfile = Path(\"C:/Users/raven/Videos/Big Buck Bunny.mkv\") # Path works\n\nconfig = \"D:/data/usenet/config/juicenet.yaml\" # string also works\n\n# Convenient config class instead of a config file\nconfig = JuicenetConfig(\n    nyuu_config_private=\"D:/data/usenet/juicenetConfig/nyuu-config.json\",\n    nzb_output_path=Path(\"D:/data/usenet/nzbs\"),\n)\n\nupload = juicenet(file, config=config)\n\nprint(upload.nyuu.nzb)\n# D:/data/usenet/nzbs/private/Videos/Big Buck Bunny.mkv.nzb\n</code></pre> Source code in <code>src/juicenet/api/main.py</code> <pre><code>def juicenet(\n    path: StrPath,\n    /,\n    *,\n    config: StrPath | JuicenetConfig,\n    public: bool = False,\n    bdmv_naming: bool = False,\n    resume: bool = True,\n    skip_raw: bool = False,\n    debug: bool = False,\n) -&gt; JuiceBox:\n    \"\"\"\n    Upload a file or folder to usenet. This will always produce one NZB for one input.\n\n    Parameters\n    ----------\n    path : str or pathlib.Path\n        The path to an existing file. This can either be a string representing the path or a pathlib.Path object.\n    config : str or pathlib.Path or JuicenetConfig\n        The configuration to use when processing the file or directory.\n        This can either be a string representing the path to a YAML configuration file,\n        a `pathlib.Path` object pointing to a YAML configuration file,\n        or a `juicenet.JuicenetConfig` dataclass.\n    public : bool, optional\n        Whether the upload is meant to be public or not. Uses the public config if specified,\n        falls back to using the private one if not. Default is False.\n    bdmv_naming : bool, optional\n        Whether to use an alternate naming for BDMVs.\n        This will try to fix the awful BDMV disc naming in some cases, i.e, if you pass `/BDMVs/Big Buck Bunny [Vol.1]/DISC_01`,\n        then the resulting NZB will be renamed to `Big Buck Bunny [Vol.1]_DISC_01.nzb` instead of `DISC_01.nzb`.\n        Recommended if your input is a BDMV disc and you're uncertain about how they are named. Keep it `False` if you're\n        certain that your BDMV discs are named appropriately. Only works on directory input,\n        does nothing (i.e, `False`) if your input is a file.\n    resume: bool, optional\n        Whether to enable resumability. Files uploaded by previous runs will be skipped if True. Default is True.\n    skip_raw: bool, optional\n        Skip checking and reposting failed raw articles. Default is False.\n    debug : bool, optional\n        Whether to enable debug logs. Default is False.\n\n    Returns\n    -------\n    JuiceBox\n        Dataclass used to represent the output of Juicenet.\n\n    Raises\n    ------\n    JuicenetInputError\n        Invalid input.\n\n    Notes\n    -----\n    - You should never upload an entire directory consisting of several files as a single NZB.\n      Use `juicenet.get_files` or `juicenet.get_glob_matches` to first get the relevant files and\n      then pass each one to juicenet.\n\n    - You should never upload an entire BDMV consisting of several discs as a single NZB.\n      Use `juicenet.get_bdmv_discs` to first get each individual disc and then pass each one to juicenet.\n\n    Examples\n    --------\n    ```python\n    from pathlib import Path\n\n    from juicenet import JuicenetConfig, juicenet\n\n    file = Path(\"C:/Users/raven/Videos/Big Buck Bunny.mkv\") # Path works\n\n    config = \"D:/data/usenet/config/juicenet.yaml\" # string also works\n\n    # Convenient config class instead of a config file\n    config = JuicenetConfig(\n        nyuu_config_private=\"D:/data/usenet/juicenetConfig/nyuu-config.json\",\n        nzb_output_path=Path(\"D:/data/usenet/nzbs\"),\n    )\n\n    upload = juicenet(file, config=config)\n\n    print(upload.nyuu.nzb)\n    # D:/data/usenet/nzbs/private/Videos/Big Buck Bunny.mkv.nzb\n    ```\n    \"\"\"\n\n    if isinstance(path, str):\n        _path = Path(path).resolve()\n    elif isinstance(path, Path):\n        _path = path.resolve()\n    else:\n        raise JuicenetInputError(\"Path must be a string or pathlib.Path\")\n\n    if not _path.exists():\n        raise JuicenetInputError(f\"{_path} must be an existing file or directory\")\n\n    filelist = filter_empty_files([_path])\n\n    if len(filelist) == 1:\n        file = filelist[0]\n    else:\n        raise JuicenetInputError(f\"{_path} is empty (0-byte)!\")\n\n    if isinstance(config, str):\n        _config = Path(config).resolve()\n    elif isinstance(config, Path):\n        _config = config.resolve()\n    elif isinstance(config, JuicenetConfig):\n        _config = config  # type: ignore\n    else:\n        raise JuicenetInputError(\"Config must be a path or a juicenet.JuicenetConfig\")\n\n    # Read config file\n    config_data = read_config(_config)\n\n    # Get the values from config\n    nyuu_bin = config_data.nyuu\n    parpar_bin = config_data.parpar\n    priv_conf = config_data.nyuu_config_private\n    pub_conf = config_data.nyuu_config_public or priv_conf\n    nzb_out = config_data.nzb_output_path\n    parpar_args = config_data.parpar_args\n    related_exts = config_data.related_extensions\n\n    appdata_dir = config_data.appdata_dir_path\n    appdata_dir.mkdir(parents=True, exist_ok=True)\n    resume_file = appdata_dir / \"juicenet.resume\"\n    resume_file.touch(exist_ok=True)\n\n    if config_data.use_temp_dir:\n        work_dir = config_data.temp_dir_path\n    else:\n        work_dir = None\n\n    # Decide which config file to use\n    configurations = {\"public\": pub_conf, \"private\": priv_conf}\n    scope = \"public\" if public else \"private\"\n    conf = configurations[scope]\n\n    # Check and get `dump-failed-posts` as defined in Nyuu config\n    dump = get_dump_failed_posts(conf)\n    raw_articles = get_glob_matches(dump, [\"*\"])\n    raw_count = len(raw_articles)\n\n    # Initialize Resume class\n    no_resume = not resume\n    _resume = Resume(resume_file, scope, no_resume)\n\n    # Initialize ParPar class for generating par2 files ahead\n    parpar = ParPar(parpar_bin, parpar_args, work_dir, debug)\n\n    # Force disable BDMV naming for file input\n    if file.is_file():\n        bdmv_naming = False\n\n    # Initialize Nyuu class for uploading stuff ahead\n    nyuu = Nyuu(file.parent.parent, nyuu_bin, conf, work_dir, nzb_out, scope, debug, bdmv_naming)\n\n    if raw_count and (not skip_raw):\n        rawoutput = {}\n        for article in raw_articles:\n            raw_out = nyuu.repost_raw(article=article)\n            rawoutput[article] = raw_out\n\n    else:\n        rawoutput = {}\n\n    if _resume.already_uploaded(file):\n        return JuiceBox(\n            nyuu=NyuuOutput(nzb=None, success=False, args=[], returncode=1, stdout=\"\", stderr=\"\"),\n            parpar=ParParOutput(\n                par2files=[],\n                success=False,\n                filepathbase=file.parent,\n                filepathformat=\"basename\" if file.is_file() else \"path\",\n                args=[],\n                returncode=1,\n                stdout=\"\",\n                stderr=\"\",\n            ),\n            raw={},\n            skipped=True,\n        )\n    else:\n        related_files = None\n\n        if file.is_file():\n            related_files = get_related_files(file, exts=related_exts)\n\n        parpar_out = parpar.generate_par2_files(file, related_files=related_files)\n        nyuu_out = nyuu.upload(file=file, related_files=related_files, par2files=parpar_out.par2files)\n\n        if nyuu_out.success:\n            # Only save it to resume if it was successful\n            _resume.log_file_info(file)\n\n    return JuiceBox(nyuu=nyuu_out, parpar=parpar_out, raw=rawoutput, skipped=False)\n</code></pre>"},{"location":"api-reference/#juicenet.get_files","title":"get_files","text":"<pre><code>get_files(\n    path: StrPath, /, *, exts: list[str] = [\"mkv\"]\n) -&gt; list[Path]\n</code></pre> <p>Get a list of files with specified extensions from the given path. This is recursive.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>The path to an existing file. This can either be a string representing the path or a pathlib.Path object.</p> required <code>exts</code> <code>list[str]</code> <p>List of file extensions to match. Default will match all <code>mkv</code> files in base path.</p> <code>['mkv']</code> <p>Returns:</p> Type Description <code>list[Path]</code> <p>A list of Path objects representing the files with the specified extensions.</p> <p>Raises:</p> Type Description <code>JuicenetInputError</code> <p>Invalid input.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_files(Path('/path/to/directory'))\n[PosixPath('/path/to/directory/Big Buck Bunny S01E01.mkv'), PosixPath('/path/to/directory/Big Buck Bunny S01E02.mkv')]\n</code></pre> <pre><code>&gt;&gt;&gt; get_files(Path('/path/to/directory'), ['txt', 'csv'])\n[PosixPath('/path/to/directory/file1.txt'), PosixPath('/path/to/directory/file2.csv')]\n</code></pre> Source code in <code>src/juicenet/api/utils.py</code> <pre><code>def get_files(path: StrPath, /, *, exts: list[str] = [\"mkv\"]) -&gt; list[Path]:\n    \"\"\"\n    Get a list of files with specified extensions from the given path. This is recursive.\n\n    Parameters\n    ----------\n    path : str or pathlib.Path\n        The path to an existing file. This can either be a string representing the path or a pathlib.Path object.\n    exts : list[str], optional\n        List of file extensions to match. Default will match all `mkv` files in base path.\n\n    Returns\n    -------\n    list[Path]\n        A list of Path objects representing the files with the specified extensions.\n\n    Raises\n    ------\n    JuicenetInputError\n        Invalid input.\n\n    Examples\n    --------\n    &gt;&gt;&gt; get_files(Path('/path/to/directory'))\n    [PosixPath('/path/to/directory/Big Buck Bunny S01E01.mkv'), PosixPath('/path/to/directory/Big Buck Bunny S01E02.mkv')]\n\n    &gt;&gt;&gt; get_files(Path('/path/to/directory'), ['txt', 'csv'])\n    [PosixPath('/path/to/directory/file1.txt'), PosixPath('/path/to/directory/file2.csv')]\n    \"\"\"\n\n    if isinstance(path, str):\n        basepath = Path(path).resolve()\n    elif isinstance(path, Path):\n        basepath = path.resolve()\n    else:\n        raise JuicenetInputError(f\"{path} must be a string or pathlib.Path\")\n\n    if not basepath.is_dir():\n        raise JuicenetInputError(f\"{basepath} must be an directory\")\n\n    files = []\n\n    for ext in exts:\n        matches = list(basepath.rglob(f\"*.{ext.strip('.')}\"))\n        files.extend(matches)\n\n    return files\n</code></pre>"},{"location":"api-reference/#juicenet.get_glob_matches","title":"get_glob_matches","text":"<pre><code>get_glob_matches(\n    path: Path, /, *, globs: list[str] = [\"*.mkv\"]\n) -&gt; list[Path]\n</code></pre> <p>Get a list of files which match at least one of the given glob patterns in the specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path or str</code> <p>The path to an existing directory. This can either be a string representing the path or a pathlib.Path object.</p> required <code>globs</code> <code>list[str]</code> <p>List of glob patterns to match. Default will match all <code>mkv</code> files in the base path.</p> <code>['*.mkv']</code> <p>Returns:</p> Type Description <code>list[Path]</code> <p>A list of Path objects representing the files matching the given glob patterns.</p> <p>Raises:</p> Type Description <code>JuicenetInputError</code> <p>Invalid input.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_glob_matches(Path('/path/to/directory'))\n[PosixPath('/path/to/directory/Big Buck Bunny S01E01.mkv'), PosixPath('/path/to/directory/Big Buck Bunny S01E02.mkv')]\n</code></pre> <pre><code>&gt;&gt;&gt; get_glob_matches(Path('/path/to/directory'), globs=['*.txt', '*.csv'])\n[PosixPath('/path/to/directory/file1.txt'), PosixPath('/path/to/directory/file2.csv')]\n</code></pre> Source code in <code>src/juicenet/api/utils.py</code> <pre><code>def get_glob_matches(path: Path, /, *, globs: list[str] = [\"*.mkv\"]) -&gt; list[Path]:\n    \"\"\"\n    Get a list of files which match at least one of the given glob patterns in the specified path.\n\n    Parameters\n    ----------\n    path : Path or str\n        The path to an existing directory. This can either be a string representing the path or a pathlib.Path object.\n    globs : list[str], optional\n        List of glob patterns to match. Default will match all `mkv` files in the base path.\n\n    Returns\n    -------\n    list[Path]\n        A list of Path objects representing the files matching the given glob patterns.\n\n    Raises\n    ------\n    JuicenetInputError\n        Invalid input.\n\n    Examples\n    --------\n    &gt;&gt;&gt; get_glob_matches(Path('/path/to/directory'))\n    [PosixPath('/path/to/directory/Big Buck Bunny S01E01.mkv'), PosixPath('/path/to/directory/Big Buck Bunny S01E02.mkv')]\n\n    &gt;&gt;&gt; get_glob_matches(Path('/path/to/directory'), globs=['*.txt', '*.csv'])\n    [PosixPath('/path/to/directory/file1.txt'), PosixPath('/path/to/directory/file2.csv')]\n    \"\"\"\n\n    if isinstance(path, str):\n        basepath = Path(path).resolve()\n    elif isinstance(path, Path):\n        basepath = path.resolve()\n    else:\n        raise JuicenetInputError(f\"{path} must be a string or pathlib.Path\")\n\n    if not basepath.is_dir():\n        raise JuicenetInputError(f\"{basepath} must be an directory\")\n\n    files = []\n\n    for glob in globs:\n        matches = list(basepath.glob(glob))\n        files.extend(matches)\n\n    return files\n</code></pre>"},{"location":"api-reference/#juicenet.get_bdmv_discs","title":"get_bdmv_discs","text":"<pre><code>get_bdmv_discs(\n    path: StrPath, globs: list[str] = [\"*/\"]\n) -&gt; list[Path]\n</code></pre> <p>Finds individual discs in BDMVs by looking for <code>BDMV/index.bdmv</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>The path to an existing file. This can either be a string representing the path or a pathlib.Path object.</p> required <code>globs</code> <code>list[str]</code> <p>List of glob patterns to match. Default will match all sub folders in base path.</p> <code>['*/']</code> <p>Returns:</p> Type Description <code>list[Path]</code> <p>List of paths where each path is a BDMV disc.</p> <p>Raises:</p> Type Description <code>JuicenetInputError</code> <p>Invalid input.</p> Notes <p>The choice to use <code>BDMV/index.bdmv</code> is arbitrary, I just needed something unique enough.</p> <p>There's two aspects to it, if the BDMV has multiple <code>BDMV/index.bdmv</code> files it means it's got multiple discs and each disc will be returned seperately and if there's only one <code>BDMV/index.bdmv</code> then return the folder as is because it's likely a movie BDMV</p> <p>A typical BDMV might look like this:</p> <p><pre><code>[BDMV] Big Buck Bunny [US]\n\u251c\u2500\u2500  Big Buck Bunny [Vol.1]\n\u2502   \u2514\u2500\u2500 DISC_01\n\u2502       \u2514\u2500\u2500 BDMV\n\u2502           \u251c\u2500\u2500 BACKUP\n\u2502           \u251c\u2500\u2500 CLIPINF\n\u2502           \u251c\u2500\u2500 META\n\u2502           \u251c\u2500\u2500 PLAYLIST\n\u2502           \u251c\u2500\u2500 index.bdmv\n\u2502           \u2514\u2500\u2500 MovieObject.bdmv\n\u2514\u2500\u2500 Big Buck Bunny [Vol.2]\n    \u2514\u2500\u2500 DISC_01\n        \u2514\u2500\u2500 BDMV\n            \u251c\u2500\u2500 BACKUP\n            \u251c\u2500\u2500 CLIPINF\n            \u251c\u2500\u2500 META\n            \u251c\u2500\u2500 PLAYLIST\n            \u251c\u2500\u2500 index.bdmv\n            \u2514\u2500\u2500 MovieObject.bdmv\n</code></pre> From the above example, this function finds the <code>BDMV/index.bdmv</code> file and then goes 1 directory up relative to <code>BDMV/index.bdmv</code> which ends up being <code>DISC_01</code></p> <p>Something like:</p> <ul> <li> <p>Found:</p> <ul> <li><code>Big Buck Bunny [Vol.1]/DISC_01/BDMV/index.bdmv</code></li> <li><code>Big Buck Bunny [Vol.2]/DISC_01/BDMV/index.bdmv</code></li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>Big Buck Bunny [Vol.1]/DISC_01</code></li> <li><code>Big Buck Bunny [Vol.2]/DISC_01</code></li> </ul> </li> </ul> <p>Examples:</p> <pre><code>from pathlib import Path\n\nfrom juicenet import get_bdmv_discs\n\nfolder = Path(\"C:/Users/raven/BDMVs\")\n\nbdmvs = get_bdmv_discs(folder)\n\nprint(bdmvs)\n# [\n#   WindowsPath('C:/Users/raven/BDMVs/[BDMV] Big Buck Bunny [US]/Big Buck Bunny [Vol.1]/DISC_01'),\n#   WindowsPath('C:/Users/raven/BDMVs/[BDMV] Big Buck Bunny [US]/Big Buck Bunny [Vol.2]/DISC_01'),\n#   WindowsPath('C:/Users/raven/BDMVs/[BDMV] Big Buck Bunny [US]/Big Buck Bunny [Vol.3]/DISC_01'),\n#   WindowsPath('C:/Users/raven/BDMVs/[BDMV] Big Buck Bunny [US]/Big Buck Bunny [Vol.4]/DISC_01'),\n#   WindowsPath('C:/Users/raven/BDMVs/[BDMV] Big Buck Bunny [US]/Big Buck Bunny [Vol.5]/DISC_01'),\n#   WindowsPath('C:/Users/raven/BDMVs/[BDMV] Big Buck Bunny [US]/Big Buck Bunny [Vol.6]/DISC_01'),\n# ]\n</code></pre> Source code in <code>src/juicenet/api/utils.py</code> <pre><code>def get_bdmv_discs(path: StrPath, globs: list[str] = [\"*/\"]) -&gt; list[Path]:\n    \"\"\"\n    Finds individual discs in BDMVs by looking for `BDMV/index.bdmv`.\n\n    Parameters\n    ----------\n    path : str or pathlib.Path\n        The path to an existing file. This can either be a string representing the path or a pathlib.Path object.\n    globs : list[str], optional\n        List of glob patterns to match. Default will match all sub folders in base path.\n\n    Returns\n    -------\n    list[Path]\n        List of paths where each path is a BDMV disc.\n\n    Raises\n    ------\n    JuicenetInputError\n        Invalid input.\n\n    Notes\n    -----\n    The choice to use `BDMV/index.bdmv` is arbitrary,\n    I just needed something unique enough.\n\n    There's two aspects to it, if the BDMV has multiple `BDMV/index.bdmv` files\n    it means it's got multiple discs and each disc will be returned seperately\n    and if there's only one `BDMV/index.bdmv` then return the folder as is\n    because it's likely a movie BDMV\n\n    A typical BDMV might look like this:\n\n    ```\n    [BDMV] Big Buck Bunny [US]\n    \u251c\u2500\u2500  Big Buck Bunny [Vol.1]\n    \u2502   \u2514\u2500\u2500 DISC_01\n    \u2502       \u2514\u2500\u2500 BDMV\n    \u2502           \u251c\u2500\u2500 BACKUP\n    \u2502           \u251c\u2500\u2500 CLIPINF\n    \u2502           \u251c\u2500\u2500 META\n    \u2502           \u251c\u2500\u2500 PLAYLIST\n    \u2502           \u251c\u2500\u2500 index.bdmv\n    \u2502           \u2514\u2500\u2500 MovieObject.bdmv\n    \u2514\u2500\u2500 Big Buck Bunny [Vol.2]\n        \u2514\u2500\u2500 DISC_01\n            \u2514\u2500\u2500 BDMV\n                \u251c\u2500\u2500 BACKUP\n                \u251c\u2500\u2500 CLIPINF\n                \u251c\u2500\u2500 META\n                \u251c\u2500\u2500 PLAYLIST\n                \u251c\u2500\u2500 index.bdmv\n                \u2514\u2500\u2500 MovieObject.bdmv\n    ```\n    From the above example, this function finds the\n    `BDMV/index.bdmv` file and then goes 1 directory up\n    relative to `BDMV/index.bdmv` which ends up being `DISC_01`\n\n    Something like:\n\n    - Found:\n        - `Big Buck Bunny [Vol.1]/DISC_01/BDMV/index.bdmv`\n        - `Big Buck Bunny [Vol.2]/DISC_01/BDMV/index.bdmv`\n\n    - Returns:\n        - `Big Buck Bunny [Vol.1]/DISC_01`\n        - `Big Buck Bunny [Vol.2]/DISC_01`\n\n    Examples\n    --------\n    ```python\n    from pathlib import Path\n\n    from juicenet import get_bdmv_discs\n\n    folder = Path(\"C:/Users/raven/BDMVs\")\n\n    bdmvs = get_bdmv_discs(folder)\n\n    print(bdmvs)\n    # [\n    #   WindowsPath('C:/Users/raven/BDMVs/[BDMV] Big Buck Bunny [US]/Big Buck Bunny [Vol.1]/DISC_01'),\n    #   WindowsPath('C:/Users/raven/BDMVs/[BDMV] Big Buck Bunny [US]/Big Buck Bunny [Vol.2]/DISC_01'),\n    #   WindowsPath('C:/Users/raven/BDMVs/[BDMV] Big Buck Bunny [US]/Big Buck Bunny [Vol.3]/DISC_01'),\n    #   WindowsPath('C:/Users/raven/BDMVs/[BDMV] Big Buck Bunny [US]/Big Buck Bunny [Vol.4]/DISC_01'),\n    #   WindowsPath('C:/Users/raven/BDMVs/[BDMV] Big Buck Bunny [US]/Big Buck Bunny [Vol.5]/DISC_01'),\n    #   WindowsPath('C:/Users/raven/BDMVs/[BDMV] Big Buck Bunny [US]/Big Buck Bunny [Vol.6]/DISC_01'),\n    # ]\n    ```\n    \"\"\"\n\n    if isinstance(path, str):\n        basepath = Path(path).resolve()\n    elif isinstance(path, Path):\n        basepath = path.resolve()\n    else:\n        raise JuicenetInputError(f\"{path} must be a string or pathlib.Path\")\n\n    if not basepath.exists():\n        raise JuicenetInputError(f\"{basepath} must be an existing file or directory\")\n\n    return _get_bdmv_discs(basepath, globs)\n</code></pre>"},{"location":"api-reference/#juicenet.get_dvd_discs","title":"get_dvd_discs","text":"<pre><code>get_dvd_discs(\n    path: StrPath, globs: list[str] = [\"*/\"]\n) -&gt; list[Path]\n</code></pre> <p>Finds individual discs in DVDs by looking for <code>VIDEO_TS/VIDEO_TS.VOB</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>The path to an existing file. This can either be a string representing the path or a pathlib.Path object.</p> required <code>globs</code> <code>list[str]</code> <p>List of glob patterns to match. Default will match all sub folders in base path.</p> <code>['*/']</code> <p>Returns:</p> Type Description <code>list[Path]</code> <p>List of paths where each path is a BDMV disc.</p> <p>Raises:</p> Type Description <code>JuicenetInputError</code> <p>Invalid input.</p> Notes <p>Finds individual discs in DVDs by looking for <code>VIDEO_TS/VIDEO_TS.VOB</code></p> <p>The choice to use <code>VIDEO_TS/VIDEO_TS.VOB</code> is arbitrary, I just needed something unique enough.</p> <p>A typical DVD might look like this:</p> <p><pre><code>Cowboy.Bebop.1998.DVDR.NTSC.R4.LATiNO\n\u251c\u2500\u2500 COWBOY_BEBOP_1\n\u2502   \u2514\u2500\u2500 VIDEO_TS\n\u2502       \u251c\u2500\u2500 VIDEO_TS.BUP\n\u2502       \u251c\u2500\u2500 VIDEO_TS.IFO\n\u2502       \u2514\u2500\u2500 VIDEO_TS.VOB\n\u2514\u2500\u2500 COWBOY_BEBOP_2\n    \u2514\u2500\u2500 VIDEO_TS\n        \u251c\u2500\u2500 VIDEO_TS.BUP\n        \u251c\u2500\u2500 VIDEO_TS.IFO\n        \u2514\u2500\u2500 VIDEO_TS.VOB\n</code></pre> From the above example, this function finds the <code>VIDEO_TS/VIDEO_TS.VOB</code> file and then goes 1 directory up relative to <code>VIDEO_TS/VIDEO_TS.VOB</code> which ends up being <code>COWBOY_BEBOP_1</code></p> <p>Practical Examples:</p> <ul> <li> <p>Found:</p> <ul> <li><code>Cowboy.Bebop.1998.DVDR.NTSC.R4.LATiNO/COWBOY_BEBOP_1/VIDEO_TS/VIDEO_TS.VOB</code></li> <li><code>Cowboy.Bebop.1998.DVDR.NTSC.R4.LATiNO/COWBOY_BEBOP_2/VIDEO_TS/VIDEO_TS.VOB</code></li> </ul> </li> <li> <p>Return:</p> <ul> <li><code>Cowboy.Bebop.1998.DVDR.NTSC.R4.LATiNO/COWBOY_BEBOP_1</code></li> <li><code>Cowboy.Bebop.1998.DVDR.NTSC.R4.LATiNO/COWBOY_BEBOP_2</code></li> </ul> </li> </ul> Source code in <code>src/juicenet/api/utils.py</code> <pre><code>def get_dvd_discs(path: StrPath, globs: list[str] = [\"*/\"]) -&gt; list[Path]:\n    \"\"\"\n    Finds individual discs in DVDs by looking for `VIDEO_TS/VIDEO_TS.VOB`.\n\n    Parameters\n    ----------\n    path : str or pathlib.Path\n        The path to an existing file. This can either be a string representing the path or a pathlib.Path object.\n    globs : list[str], optional\n        List of glob patterns to match. Default will match all sub folders in base path.\n\n    Returns\n    -------\n    list[Path]\n        List of paths where each path is a BDMV disc.\n\n    Raises\n    ------\n    JuicenetInputError\n        Invalid input.\n\n    Notes\n    -----\n    Finds individual discs in DVDs by looking for `VIDEO_TS/VIDEO_TS.VOB`\n\n    The choice to use `VIDEO_TS/VIDEO_TS.VOB` is arbitrary,\n    I just needed something unique enough.\n\n    A typical DVD might look like this:\n\n    ```\n    Cowboy.Bebop.1998.DVDR.NTSC.R4.LATiNO\n    \u251c\u2500\u2500 COWBOY_BEBOP_1\n    \u2502   \u2514\u2500\u2500 VIDEO_TS\n    \u2502       \u251c\u2500\u2500 VIDEO_TS.BUP\n    \u2502       \u251c\u2500\u2500 VIDEO_TS.IFO\n    \u2502       \u2514\u2500\u2500 VIDEO_TS.VOB\n    \u2514\u2500\u2500 COWBOY_BEBOP_2\n        \u2514\u2500\u2500 VIDEO_TS\n            \u251c\u2500\u2500 VIDEO_TS.BUP\n            \u251c\u2500\u2500 VIDEO_TS.IFO\n            \u2514\u2500\u2500 VIDEO_TS.VOB\n    ```\n    From the above example, this function finds the\n    `VIDEO_TS/VIDEO_TS.VOB` file and then goes 1 directory up\n    relative to `VIDEO_TS/VIDEO_TS.VOB` which ends up being `COWBOY_BEBOP_1`\n\n    Practical Examples:\n\n    - Found:\n        - `Cowboy.Bebop.1998.DVDR.NTSC.R4.LATiNO/COWBOY_BEBOP_1/VIDEO_TS/VIDEO_TS.VOB`\n        - `Cowboy.Bebop.1998.DVDR.NTSC.R4.LATiNO/COWBOY_BEBOP_2/VIDEO_TS/VIDEO_TS.VOB`\n\n    - Return:\n        - `Cowboy.Bebop.1998.DVDR.NTSC.R4.LATiNO/COWBOY_BEBOP_1`\n        - `Cowboy.Bebop.1998.DVDR.NTSC.R4.LATiNO/COWBOY_BEBOP_2`\n    \"\"\"\n\n    if isinstance(path, str):\n        basepath = Path(path).resolve()\n    elif isinstance(path, Path):\n        basepath = path.resolve()\n    else:\n        raise JuicenetInputError(f\"{path} must be a string or pathlib.Path\")\n\n    if not basepath.exists():\n        raise JuicenetInputError(f\"{basepath} must be an existing file or directory\")\n\n    return _get_dvd_discs(basepath, globs)\n</code></pre>"},{"location":"api-reference/#juicenet.JuicenetConfig","title":"JuicenetConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model for setting defaults and validating Juicenet's config</p> <p>Attributes:</p> Name Type Description <code>parpar</code> <code>FilePath</code> <p>The path to the ParPar executable</p> <code>nyuu</code> <code>FilePath</code> <p>The path to the Nyuu executable</p> <code>nyuu_config_private</code> <code>FilePath</code> <p>The path to the private Nyuu configuration file</p> <code>nzb_output_path</code> <code>DirectoryPath</code> <p>The path where output NZBs will be saved</p> <code>nyuu_config_public</code> <code>(FilePath, optional)</code> <p>The path to the public Nyuu configuration file</p> <code>extensions</code> <code>(list[str], optional)</code> <p>The list of file extensions to be processed. Default is <code>[\"mkv\"]</code></p> <code>related_extensions</code> <code>(list[str], optional)</code> <p>The list of file extensions associated with an input file. For example, if you have a file named <code>Big Buck Bunny The Movie (2023).mkv</code>, another file named <code>Big Buck Bunny The Movie (2023).srt</code> is considered related. Default is <code>[\"*\"]</code></p> <code>parpar_args</code> <code>(list[str], optional)</code> <p>The arguments to be passed to the ParPar executable Ddefault is <code>[\"--overwrite\", \"-s700k\", \"--slice-size-multiple=700K\", \"--max-input-slices=4000\", \"-r1n*1.2\", \"-R\"]</code></p> <code>use_temp_dir</code> <code>(bool, optional)</code> <p>Whether or not to use a temporary directory for processing. Default is <code>True</code></p> <code>temp_dir_path</code> <code>(DirectoryPath, optional)</code> <p>Path to a specific temporary directory if <code>use_temp_dir</code> is <code>True</code>. If unspecified, it uses <code>%Temp%</code> or <code>/tmp</code></p> <code>appdata_dir_path</code> <code>(Path, optional)</code> <p>The path to the folder where Juicenet will store its data. Default is <code>~/.juicenet</code></p> Source code in <code>src/juicenet/model.py</code> <pre><code>class JuicenetConfig(BaseModel):\n    \"\"\"\n    Pydantic model for setting defaults and validating Juicenet's config\n\n    Attributes\n    ----------\n    parpar : FilePath\n        The path to the ParPar executable\n    nyuu : FilePath\n        The path to the Nyuu executable\n    nyuu_config_private : FilePath\n        The path to the private Nyuu configuration file\n    nzb_output_path : DirectoryPath\n        The path where output NZBs will be saved\n    nyuu_config_public : FilePath, optional\n        The path to the public Nyuu configuration file\n    extensions : list[str], optional\n        The list of file extensions to be processed. Default is `[\"mkv\"]`\n    related_extensions : list[str], optional\n        The list of file extensions associated with an input file.\n        For example, if you have a file named `Big Buck Bunny The Movie (2023).mkv`,\n        another file named `Big Buck Bunny The Movie (2023).srt` is considered related.\n        Default is `[\"*\"]`\n    parpar_args : list[str], optional\n        The arguments to be passed to the ParPar executable\n        Ddefault is `[\"--overwrite\", \"-s700k\", \"--slice-size-multiple=700K\", \"--max-input-slices=4000\", \"-r1n*1.2\", \"-R\"]`\n    use_temp_dir : bool, optional\n        Whether or not to use a temporary directory for processing. Default is `True`\n    temp_dir_path : DirectoryPath, optional\n        Path to a specific temporary directory if `use_temp_dir` is `True`. If unspecified, it uses `%Temp%` or `/tmp`\n    appdata_dir_path : Path, optional\n        The path to the folder where Juicenet will store its data. Default is `~/.juicenet`\n    \"\"\"\n\n    parpar: Annotated[FilePath, Field(validate_default=True)] = which(\"parpar\") # type: ignore\n    \"\"\"The path to the ParPar executable\"\"\"\n\n    nyuu: Annotated[FilePath, Field(validate_default=True)] = which(\"nyuu\") # type: ignore\n    \"\"\"The path to the Nyuu executable\"\"\"\n\n    nyuu_config_private: FilePath\n    \"\"\"The path to the private Nyuu configuration file\"\"\"\n\n    nzb_output_path: DirectoryPath\n    \"\"\"The path where output NZBs will be saved\"\"\"\n\n    nyuu_config_public: Optional[FilePath] = None\n    \"\"\"The path to the public Nyuu configuration file\"\"\"\n\n    extensions: list[str] = [\"mkv\"]\n    \"\"\"The list of file extensions to be processed\"\"\"\n\n    related_extensions: list[str] = [\"ass\", \"srt\"]\n    \"\"\"\n    The list of file extensions associated with an input file. \n    For example, if you have a file named `Big Buck Bunny The Movie (2023).mkv`, \n    another file named `Big Buck Bunny The Movie (2023).srt` is considered related\n    \"\"\"\n\n    parpar_args: list[str] = [\"--overwrite\", \"-s700k\", \"--slice-size-multiple=700K\", \"--max-input-slices=4000\", \"-r1n*1.2\", \"-R\"]\n    \"\"\"The arguments to be passed to the ParPar executable\"\"\"\n\n    use_temp_dir: bool = True\n    \"\"\"Whether or not to use a temporary directory for processing\"\"\"\n\n    temp_dir_path: DirectoryPath = Path(TemporaryDirectory(prefix=\".JUICENET_\").name).resolve()\n    \"\"\"Path to a specific temporary directory if use_temp_dir is True. If unspecified, it uses %Temp% or /tmp\"\"\"\n\n    appdata_dir_path: Path = Path.home() / \".juicenet\"\n    \"\"\"The path to the folder where juicenet will store it's data\"\"\"\n\n    @field_validator(\"parpar\", \"nyuu\", \"nyuu_config_private\", \"nzb_output_path\", \"nyuu_config_public\", \"temp_dir_path\", \"appdata_dir_path\")\n    @classmethod\n    def resolve_path(cls, path: Path) -&gt; Path:\n            \"\"\"Resolve all given Path fields\"\"\"\n            return path.expanduser().resolve()\n</code></pre>"},{"location":"api-reference/#juicenet.JuiceBox","title":"JuiceBox  <code>dataclass</code>","text":"<p>A class used to represent the output of juicenet. Each attribute in this class is an instance of the corresponding output class (<code>NyuuOutput</code>, <code>ParParOutput</code>, <code>RawOutput</code>) and captures the output of the respective subprocess.</p> <p>Attributes:</p> Name Type Description <code>nyuu</code> <code>NyuuOutput</code> <p><code>NyuuOutput</code> object for the processed file.</p> <code>parpar</code> <code>ParParOutput</code> <p><code>ParParOutput</code> object for the processed file.</p> <code>raw</code> <code>dict[ArticleFilePath, RawOutput]</code> <p>Dictionary where each key is an article and the value is <code>RawOutput</code> object. Empty if no articles were processed.</p> <code>skipped</code> <code>bool</code> <p>True if the upload process was skipped because the file was already uploaded</p> Source code in <code>src/juicenet/types.py</code> <pre><code>@dataclass(order=True)\nclass JuiceBox:\n    \"\"\"\n    A class used to represent the output of juicenet.\n    Each attribute in this class is an instance of the corresponding output class (`NyuuOutput`, `ParParOutput`, `RawOutput`) and\n    captures the output of the respective subprocess.\n\n    Attributes\n    ----------\n    nyuu : NyuuOutput\n        `NyuuOutput` object for the processed file.\n    parpar : ParParOutput\n        `ParParOutput` object for the processed file.\n    raw: dict[ArticleFilePath, RawOutput]\n        Dictionary where each key is an article and the value is `RawOutput` object.\n        Empty if no articles were processed.\n    skipped: bool\n        True if the upload process was skipped because the file was already uploaded\n    \"\"\"\n\n    nyuu: NyuuOutput\n    \"\"\"`NyuuOutput` object for the processed file.\"\"\"\n\n    parpar: ParParOutput\n    \"\"\"`ParParOutput` object for the processed file.\"\"\"\n\n    raw: dict[ArticleFilePath, RawOutput]\n    \"\"\"`RawOutput` object for any processed articles or `None` if not available.\"\"\"\n\n    skipped: bool\n    \"\"\"True if the upload process was skipped because the file was already uploaded\"\"\"\n</code></pre>"},{"location":"api-reference/#juicenet.NyuuOutput","title":"NyuuOutput  <code>dataclass</code>","text":"<p>A class used to represent the output of Nyuu.</p> <p>Attributes:</p> Name Type Description <code>nzb</code> <code>(NZBFilePath, optional)</code> <p>Absolute pathlib.Path to the resulting <code>NZB</code> file or <code>None</code> if the upload failed.</p> <code>success</code> <code>bool</code> <p><code>True</code> if Nyuu exited successfully with code 0 or 32, <code>False</code> otherwise.</p> <code>args</code> <code>list[str]</code> <p>List of arguments passed to Nyuu.</p> <code>returncode</code> <code>int</code> <p>Nyuu's exit code.</p> <code>stdout</code> <code>str</code> <p>Nyuu's stdout.</p> <code>stderr</code> <code>str</code> <p>Nyuu's stderr.</p> Notes <p>Nyuu exits with a code 0 if the process completes successfully or 32 if the process completes successfully after skipping the skippable errors.</p> <p>Refer to Nyuu's <code>help-full.txt</code> for more details.</p> Source code in <code>src/juicenet/types.py</code> <pre><code>@dataclass(order=True)\nclass NyuuOutput:\n    \"\"\"\n    A class used to represent the output of Nyuu.\n\n    Attributes\n    ----------\n    nzb : NZBFilePath, optional\n        Absolute pathlib.Path to the resulting `NZB` file or `None` if the upload failed.\n    success : bool\n        `True` if Nyuu exited successfully with code 0 or 32, `False` otherwise.\n    args : list[str]\n        List of arguments passed to Nyuu.\n    returncode : int\n        Nyuu's exit code.\n    stdout : str\n        Nyuu's stdout.\n    stderr : str\n        Nyuu's stderr.\n\n    Notes\n    -----\n    Nyuu exits with a code 0 if the process completes successfully or 32 if the\n    process completes successfully after skipping the skippable errors.\n\n    Refer to Nyuu's [`help-full.txt`](https://github.com/animetosho/Nyuu/blob/master/help-full.txt#L204-L228)\n    for more details.\n    \"\"\"\n\n    nzb: Optional[NZBFilePath]\n    \"\"\"Absolute pathlib.Path to the resulting `NZB` file or `None` if the upload failed.\"\"\"\n\n    success: bool\n    \"\"\"`True` if Nyuu exited successfully with code 0 or 32, `False` otherwise.\"\"\"\n\n    args: list[str]\n    \"\"\"List of arguments passed to Nyuu.\"\"\"\n\n    returncode: int\n    \"\"\"Nyuu's exit code.\"\"\"\n\n    stdout: str\n    \"\"\"Nyuu's stdout.\"\"\"\n\n    stderr: str\n    \"\"\"Nyuu's stderr.\"\"\"\n</code></pre>"},{"location":"api-reference/#juicenet.ParParOutput","title":"ParParOutput  <code>dataclass</code>","text":"<p>A class used to represent the output of ParPar.</p> <p>Attributes:</p> Name Type Description <code>par2files</code> <code>list[PAR2FilePath]</code> <p>List of absolute pathlib.Path objects pointing to the generated <code>PAR2</code> files.</p> <code>filepathformat</code> <code>Literal['basename', 'path']</code> <p>The <code>--filepath-format</code> used to generate the <code>PAR2</code> files.</p> <code>filepathbase</code> <code>Path</code> <p>The <code>--filepath-base</code> used to generate the <code>PAR2</code> files.</p> <code>success</code> <code>bool</code> <p><code>True</code> if ParPar exited successfully with code 0, <code>False</code> otherwise.</p> <code>args</code> <code>list[str]</code> <p>List of arguments passed to ParPar.</p> <code>returncode</code> <code>int</code> <p>ParPar's exit code.</p> <code>stdout</code> <code>str</code> <p>ParPar's stdout.</p> <code>stderr</code> <code>str</code> <p>ParPar's stderr.</p> Source code in <code>src/juicenet/types.py</code> <pre><code>@dataclass(order=True)\nclass ParParOutput:\n    \"\"\"\n    A class used to represent the output of ParPar.\n\n    Attributes\n    ----------\n    par2files : list[PAR2FilePath]\n        List of absolute pathlib.Path objects pointing to the generated `PAR2` files.\n    filepathformat : Literal[\"basename\", \"path\"]\n        The `--filepath-format` used to generate the `PAR2` files.\n    filepathbase : Path\n        The `--filepath-base` used to generate the `PAR2` files.\n    success : bool\n        `True` if ParPar exited successfully with code 0, `False` otherwise.\n    args : list[str]\n        List of arguments passed to ParPar.\n    returncode : int\n        ParPar's exit code.\n    stdout : str\n        ParPar's stdout.\n    stderr : str\n        ParPar's stderr.\n    \"\"\"\n\n    par2files: list[PAR2FilePath]\n    \"\"\"List of absolute pathlib.Path objects pointing to the generated `PAR2` files.\"\"\"\n\n    filepathformat: Literal[\"basename\", \"path\"]\n    \"\"\"The `--filepath-format` used to generate the `PAR2` files.\"\"\"\n\n    filepathbase: Path\n    \"\"\"The `--filepath-base` used to generate the `PAR2` files.\"\"\"\n\n    success: bool\n    \"\"\"`True` if ParPar exited successfully with code 0, `False` otherwise.\"\"\"\n\n    args: list[str]\n    \"\"\"List of arguments passed to ParPar.\"\"\"\n\n    returncode: int\n    \"\"\"ParPar's exit code.\"\"\"\n\n    stdout: str\n    \"\"\"ParPar's stdout.\"\"\"\n\n    stderr: str\n    \"\"\"ParPar's stderr.\"\"\"\n</code></pre>"},{"location":"api-reference/#juicenet.RawOutput","title":"RawOutput  <code>dataclass</code>","text":"<p>A class used to represent the output of Nyuu's raw article upload process.</p> <p>Attributes:</p> Name Type Description <code>article</code> <code>ArticleFilePath</code> <p>Absolute pathlib.Path to the raw article.</p> <code>success</code> <code>bool</code> <p><code>True</code> if Nyuu exited successfully with code 0 or 32, <code>False</code> otherwise.</p> <code>args</code> <code>list[str]</code> <p>List of arguments passed to Nyuu.</p> <code>returncode</code> <code>int</code> <p>Nyuu's exit code.</p> <code>stdout</code> <code>str</code> <p>Nyuu's stdout.</p> <code>stderr</code> <code>str</code> <p>Nyuu's stderr.</p> Notes <p>Nyuu exits with a code 0 if the process completes successfully or 32 if the process completes successfully after skipping the skippable errors.</p> <p>Refer to Nyuu's <code>help-full.txt</code> for more details.</p> Source code in <code>src/juicenet/types.py</code> <pre><code>@dataclass(order=True)\nclass RawOutput:\n    \"\"\"\n    A class used to represent the output of Nyuu's raw article upload process.\n\n    Attributes\n    ----------\n    article : ArticleFilePath\n        Absolute pathlib.Path to the raw article.\n    success : bool\n        `True` if Nyuu exited successfully with code 0 or 32, `False` otherwise.\n    args : list[str]\n        List of arguments passed to Nyuu.\n    returncode : int\n        Nyuu's exit code.\n    stdout : str\n        Nyuu's stdout.\n    stderr : str\n        Nyuu's stderr.\n\n    Notes\n    -----\n    Nyuu exits with a code 0 if the process completes successfully or 32 if the\n    process completes successfully after skipping the skippable errors.\n\n    Refer to Nyuu's [`help-full.txt`](https://github.com/animetosho/Nyuu/blob/master/help-full.txt#L204-L228)\n    for more details.\n    \"\"\"\n\n    article: ArticleFilePath\n    \"\"\"Absolute pathlib.Path to the raw article.\"\"\"\n\n    success: bool\n    \"\"\"`True` if Nyuu exited successfully with code 0 or 32, `False` otherwise.\"\"\"\n\n    args: list[str]\n    \"\"\"List of arguments passed to Nyuu.\"\"\"\n\n    returncode: int\n    \"\"\"Nyuu's exit code.\"\"\"\n\n    stdout: str\n    \"\"\"Nyuu's stdout.\"\"\"\n\n    stderr: str\n    \"\"\"Nyuu's stderr.\"\"\"\n</code></pre>"},{"location":"cli-reference/","title":"CLI Reference","text":""},{"location":"cli-reference/#usage","title":"Usage","text":"<p><pre><code>$ juicenet [OPTIONS] &lt;path&gt;\n</code></pre> <pre><code>$ juicenet &lt;path&gt; [OPTIONS]\n</code></pre> <pre><code>$ juicenet [OPTIONS] &lt;path&gt; [OPTIONS]\n</code></pre></p>"},{"location":"cli-reference/#options","title":"Options","text":"Positional Arguments Description <code>path</code> Directory containing your files (default: CWD) Options: Description <code>-h, --help</code> Show a help message and exit <code>--config CONFIG</code> Specify the path to your juicenet config file <code>--version</code> Show juicenet's version number and exit <code>--public</code> Use your public config <code>--nyuu</code> Only run Nyuu in <code>&lt;path&gt;</code> (default: <code>cwd</code>) <code>--parpar</code> Only run ParPar in <code>&lt;path&gt;</code> (default: <code>cwd</code>) <code>--raw</code> Only repost raw articles <code>--skip-raw</code> Skip reposting raw articles <code>--glob    [*/ ...]</code> Specify the glob pattern(s) to be matched instead of extensions <code>--bdmv</code> Find and upload BDMV discs in cwd, can be used with <code>--glob</code> <code>--dvd</code> Find and upload DVD discs in cwd, can be used with <code>--glob</code> <code>--debug</code> Show logs for debugging <code>--move</code> Move files into their own directories <code>(foobar.ext -&gt; foobar/foobar.ext)</code> and exit <code>--exts [mkv mp4 ...]</code> Look for these extensions in <code>&lt;path&gt;</code> <code>--no-resume</code> ignore resume data <code>--clear-resume</code> delete resume data <p>Info</p> <p>If you don't feel like using <code>--config</code> every single time, you can use the environment variable <code>JUICENET_CONFIG</code> to hold the path of your config file. If set, this will always be used unless overridden by explicitly passing <code>--config</code>.</p>"},{"location":"cli-reference/#examples","title":"Examples","text":"<p>Info</p> <p><code>juicenet</code> will automatically preserve structure for all folder uploads and discard them for singular files.</p> <ol> <li> <p>Uploading the files in current working directory with config passed via the environment variable <code>JUICENET_CONFIG</code></p> <p><pre><code>juicenet\n</code></pre> Yep, that's it. That'll do the rest for you.</p> </li> <li> <p>Upload a single file</p> <pre><code>juicenet \"path/to/file.mkv\" # config loaded from $JUICENET_CONFIG\n</code></pre> <pre><code>juicenet --config \"path/to/juicenet.yaml\" \"path/to/file.mkv\"\n</code></pre> </li> <li> <p>Upload files from an arbitrary directory with an explicit config</p> <pre><code>juicenet --config \"path/to/juicenet.yaml\" \"path/to/files\"\n</code></pre> </li> <li> <p>Specify arbitrary extensions at runtime, ignoring the extensions defined in config</p> <pre><code>juicenet --exts mp4 epub # CWD\n</code></pre> <pre><code>juicenet \"path/to/files\" --exts mp4 epub\n</code></pre> </li> <li> <p>Upload all subfolders in <code>&lt;path&gt;</code></p> <pre><code>juicenet --glob \"*/\" # CWD\n</code></pre> <pre><code>juicenet \"path/to/files\" --glob \"*/\"\n</code></pre> <p>Info</p> <p>Linux shells automatically expand the glob pattern before passing it to the command, quote the glob pattern to stop the expansion since we want <code>juicenet</code> to read those glob patterns.</p> </li> <li> <p>Upload all subfolders with the word \"BDMV\" anywhere in their name and all the subfolders that start with the word \"UHD\"</p> <pre><code>juicenet --glob \"*BDMV*/\" \"UHD*/\" # CWD\n</code></pre> <pre><code>juicenet \"path/to/files\" --glob \"*BDMV*/\" \"*UHD*/\"\n</code></pre> </li> <li> <p>Find and upload BDMV discs in current working directory automatically</p> <p>Note</p> <p>This may not be perfect, it simply finds BDMVs by looking for <code>BDMV/index.bdmv</code></p> <p><pre><code>juicenet \"path/to/files\" --bdmv\n</code></pre> Can be paired with <code>--glob</code> to further filter what you want to upload. For example, if you only want to find BDMV discs in folders that have the word \"BDMV\" and \"UHD\" in them, you would run the following command</p> <pre><code>juicenet \"path/to/files\" --bdmv --glob \"*BDMV*/\" \"*UHD*/\"\n</code></pre> </li> <li> <p>Only Upload E10 to E15 from a folder with all the episodes</p> <pre><code>juicenet --glob \"S01E1[0-5]\" # CWD\n</code></pre> <pre><code>juicenet \"path/to/files\" --glob \"S01E1[0-5]\"\n</code></pre> </li> </ol>"},{"location":"configuration/","title":"Configuration","text":"<p>Before you can use <code>juicenet</code>, you'll have to configure it. This is a one time thing after which you can pretty much forget about it.</p>"},{"location":"configuration/#reference","title":"Reference","text":"<p><code>juicenet</code> requires you to put your configuration in a file called <code>juicenet.yaml</code>.</p>"},{"location":"configuration/#required-keys","title":"Required keys","text":"Key Description NYUU_CONFIG_PRIVATE Path to a valid Nyuu configuration file NZB_OUTPUT_PATH Path to a directory where <code>juicenet</code> will store it's output"},{"location":"configuration/#optional-keys","title":"Optional keys","text":"Key Description Default PARPAR The path to the ParPar binary <code>PATH</code> NYUU The path to the Nyuu binary <code>PATH</code> NYUU_CONFIG_PUBLIC The path to the public Nyuu configuration file <code>NYUU_CONFIG_PRIVATE</code> EXTENSIONS The list of file extensions to be processed <code>[\"mkv\"]</code> RELATED_EXTENSIONS The list of file extensions associated with an input file. For example, if you have a file named <code>Big Buck Bunny The Movie (2023).mkv</code>, another file named <code>Big Buck Bunny The Movie (2023).srt</code> is considered related <code>[\"ass\", \"srt\"]</code> PARPAR_ARGS The arguments to be passed to the ParPar binary <code>--overwrite -s700k --slice-size-multiple=700K --max-input-slices=4000 -r1n*1.2 -R</code> USE_TEMP_DIR Whether or not to use a temporary directory for processing <code>True</code> TEMP_DIR_PATH Path to a specific temporary directory if USE_TEMP_DIR is True <code>%Temp%</code> or <code>/tmp/</code> APPDATA_DIR_PATH The path to the folder where juicenet will store its data <code>~/.juicenet</code>"},{"location":"configuration/#example-configuration-file","title":"Example configuration file","text":"<pre><code># Do not quote your paths. Paste them as is\nPARPAR: C:\\Users\\user\\bin\\parpar.exe\nNYUU: C:\\Users\\user\\bin\\nyuu.exe\n\n# https://juicenet.ravencentric.cc/nyuu-config-files/\nNYUU_CONFIG_PRIVATE: C:\\Users\\user\\nyuu\\config-private.json\n\nNZB_OUTPUT_PATH: D:\\output\\nzbs\nEXTENSIONS: [\"mkv\", \"epub\", \"cbr\", \"cbz\", \"cb7\", \"cbt\"]\n\n# Use %Temp% on Windows or /tmp on Unix for temporary files.\n# Setting it to False will generate temporary files right next to the input files\nUSE_TEMP_DIR: True\n\n# Advanced Setting (Only modify if you know what you're doing)\n# Do NOT pass -o, --filepath-format, and --filepath-base. They are handled by the script.\nPARPAR_ARGS: [\"--overwrite\", \"-s700k\", \"--slice-size-multiple=700K\", \"--max-input-slices=4000\", \"-r1n*1.2\", \"-R\"]\n</code></pre>"},{"location":"configuration/#loading-the-config-file","title":"Loading the config file","text":"<p>Now that you've got your <code>juicenet.yaml</code> ready, you have to pass it to <code>juicenet</code>. This can be achieved in one of three ways:</p> <ul> <li> <p>Using the command-line argument</p> <pre><code>juicenet --config \"path/to/juicenet.yaml\" [OPTIONS] &lt;path&gt;\n</code></pre> </li> <li> <p>Setting an environment variable named <code>JUICENET_CONFIG</code> with the full path to your <code>juicenet.yaml</code>. If you do this, it'll never fall back to using <code>juicenet.yaml</code> from current working directory. This is also convenient since you no longer have to pass <code>--config</code> everytime.</p> </li> <li>Placing the configuration file in the current working directory as <code>juicenet.yaml</code></li> </ul> <p>Note</p> <p>The order of precedence, if all three are present, is: <code>command-line argument</code> &gt; <code>environment variable</code> &gt; <code>local file in the current working directory</code></p>"},{"location":"nyuu-config-files/","title":"Configuration files for Nyuu","text":"<p>You can read what all the options do here.  You don't need to know what each option does since most likely you'll be good to go by just replacing the dummy values, but I'll recommend going through them regardless. You should also consider using a paid BLOCK account for uploading.</p>"},{"location":"nyuu-config-files/#dummy-values","title":"Dummy values","text":"<p>All three of the provided configs below have 3 dummy values that you need to replace before using:</p> <ul> <li> <p><code>\"host\":               \"your.provider.com\",</code></p> </li> <li> <p><code>\"user\":               \"coolusername\",</code></p> </li> <li> <p><code>\"password\":           \"123password\",</code></p> </li> <li> <p><code>\"dump-failed-posts\":  \"/path/to/folder\",</code></p> </li> </ul> <p>Note</p> <p>Windows paths must use double backslashes <code>\\\\</code>, e.g, <code>D:\\\\path\\\\to\\\\folder</code>.</p>"},{"location":"nyuu-config-files/#example-config-files","title":"Example config files","text":"PrivatePublicSchizo <p>This config obfuscates everything so public indexers can't index it. This will be the config you pass to <code>NYUU_CONFIG_PRIVATE</code>.</p> <pre><code>{\n    \" *** Server Options *** \":0,\n    \"host\":               \"your.provider.com\",\n    \"port\":               563,\n    \"ssl\":                true,\n    \"ignore-cert\":        false,\n    \"user\":               \"coolusername\",\n    \"password\":           \"123password\",\n    \"connections\":        20,\n\n    \" *** Article Options *** \":0,\n    \"article-size\":       \"700K\",\n    \"subject\":            \"${rand(20)}\",\n    \"comment\":            \"\",\n    \"from\":               \"${rand(10)}@${rand(5)}.${rand(3)}\",\n    \"groups\":             \"alt.binaries.boneless\",\n    \"yenc-name\":          \"${rand(15)}\",\n\n    \" *** Check Options *** \":0,\n    \"check-connections\":  5,\n    \"check-tries\":        2,\n    \"check-delay\":        \"5s\",\n    \"check-retry-delay\":  \"30s\",\n    \"check-post-tries\":   2,\n\n    \" *** NZB Options *** \":0,\n    \"out\":                \"{filename}.nzb\",\n    \"overwrite\":          true,\n    \"nzb-subject\":        \"[{filenum}/{files}] - \\\"{filename}\\\" yEnc ({part}/{parts}) {filesize}\",\n\n    \" *** Other Options *** \":0,\n    \"skip-errors\":        \"all\",\n    \"dump-failed-posts\":  \"/path/to/folder\",\n    \"quiet\":              false,\n    \"token-eval\":         false,\n\n    \" *** UI Options *** \":0,\n    \"log-time\":           true,\n\n    \" *** Input Files *** \":0,\n    \"subdirs\":            \"keep\"\n    }\n</code></pre> <p>This config does not obfuscate anything and public indexers will index it. This will be the config you pass to <code>NYUU_CONFIG_PUBLIC</code>.</p> <p>Note</p> <p>You must change <code>\"from\": \"example@example.com\",</code> in this config. This is similar to a \"username\" field for your uploads and is necessary for public indexers to index your uploads. For example, seadex uploads use <code>\"from\": \"seadex@releases.moe\",</code>. This does not need to be a real domain, so you can write whatever you want.</p> <pre><code>{\n    \" *** Server Options *** \":0,\n    \"host\":               \"your.provider.com\",\n    \"port\":               563,\n    \"ssl\":                true,\n    \"ignore-cert\":        false,\n    \"user\":               \"coolusername\",\n    \"password\":           \"123password\",\n    \"connections\":        20,\n\n    \" *** Article Options *** \":0,\n    \"article-size\":       \"700K\",\n    \"comment\":            \"\",\n    \"from\":               \"example@example.com\",\n    \"groups\":             \"alt.binaries.boneless\",\n\n    \" *** Check Options *** \":0,\n    \"check-connections\":  5,\n    \"check-tries\":        2,\n    \"check-delay\":        \"5s\",\n    \"check-retry-delay\":  \"30s\",\n    \"check-post-tries\":   2,\n\n    \" *** NZB Options *** \":0,\n    \"out\":                \"{filename}.nzb\",\n    \"overwrite\":          true,\n    \"nzb-subject\":        \"[{filenum}/{files}] - \\\"{filename}\\\" yEnc ({part}/{parts}) {filesize}\",\n\n    \" *** Other Options *** \":0,\n    \"skip-errors\":        \"all\",\n    \"dump-failed-posts\":  \"/path/to/folder\",\n    \"quiet\":              false,\n    \"token-eval\":         false,\n\n    \" *** UI Options *** \":0,\n    \"log-time\":           true,\n\n    \" *** Input Files *** \":0,\n    \"subdirs\":            \"keep\"\n    }\n</code></pre> <p>This is an alternative private config that randomizes the length of the randomizer for the schizophrenic.</p> <p>Note</p> <p>Nyuu can accept arbitrary <code>JavaScript</code> code as input, which we can use to further randomize the built in <code>${rand(N)}</code></p> <pre><code>${rand(Math.floor(Math.random()*(30-10)+10))}\n/*\nFormat: Math.floor(Math.random()*(MAX-MIN)+MIN)\nReplace the Max and Min values with whatever you feel like it.\n\nIn this example, this creates a random integer between 10 and 30,\nwhich is then used as an argument for the rand() function to generate\na random string of that length\n*/\n</code></pre> <pre><code>{\n\" *** Server Options *** \":0,\n\"host\":               \"your.provider.com\",\n\"port\":               563,\n\"ssl\":                true,\n\"ignore-cert\":        false,\n\"user\":               \"coolusername\",\n\"password\":           \"123password\",\n\"connections\":        20,\n\n\" *** Article Options *** \":0,\n\"article-size\":       \"700K\",\n\"subject\":            \"${rand(Math.floor(Math.random()*(30-10)+10))}\",\n\"comment\":            \"\",\n\"from\":               \"${rand(Math.floor(Math.random()*(20-10)+10))}@${rand(Math.floor(Math.random()*(10-5)+5))}.${rand(Math.floor(Math.random()*(5-2)+2))}\",\n\"groups\":             \"alt.binaries.boneless\",\n\"yenc-name\":          \"${rand(Math.floor(Math.random()*(20-10)+10))}\",\n\n\" *** Check Options *** \":0,\n\"check-connections\":  5,\n\"check-tries\":        2,\n\"check-delay\":        \"5s\",\n\"check-retry-delay\":  \"30s\",\n\"check-post-tries\":   2,\n\n\" *** NZB Options *** \":0,\n\"out\":                \"${filename}.nzb\",\n\"overwrite\":          true,\n\"nzb-subject\":        \"[${filenum}/${files}] - \\\"${filename}\\\" yEnc (${part}/${parts}) ${filesize}\",\n\n\" *** Other Options *** \":0,\n\"skip-errors\":        \"all\",\n\"dump-failed-posts\":  \"/path/to/folder\",\n\"quiet\":              false,\n\"token-eval\":         true,\n\n\" *** UI Options *** \":0,\n\"log-time\":           true,\n\n\" *** Input Files *** \":0,\n\"subdirs\":            \"keep\"\n}\n</code></pre>"},{"location":"nyuu-config-files/#explanation","title":"Explanation","text":"<p>You can understand what most of the options do here but I'll explain some of them here:</p> <ol> <li> <p><code>${rand(N)}</code></p> <ul> <li>This is a token accepted by various different options, resulting in a random string <code>N</code> characters long</li> <li>You use this to obfuscate uploaded nzbs to prevent them from being taken down by DMCAs and getting indexed by public indexers</li> <li>For private uploads, you should randomize <code>--subject</code>, <code>--from</code>, and <code>--yenc-name</code></li> <li>For public uploads, it's mostly upto you. If you randomize <code>--subject</code> and <code>--yenc-name</code>, then it won't get picked up by public indexers like NZBKing but it'll work just as expected if you share the NZB file</li> </ul> </li> <li> <p><code>--token-eval</code></p> <ul> <li>This option expands on the tokens like <code>${rand(N)}</code></li> <li>It allows us to input JavaScript</li> <li>For example, you can use it to generate a random number between <code>max</code> and <code>min</code> using <code>Math.floor(Math.random() * (max - min) + min)</code> and then feed that random number to <code>${rand(N)}</code></li> <li>Adjust the <code>min</code> and <code>max</code> values as you like</li> </ul> <p>Note</p> <p>You'll have to change your tokens based on whether <code>token-eval</code> is true or false. <code>{filename}</code> will work without <code>token-eval</code>, but you'll have to change it to <code>${filename}</code> to make it work with <code>--token-eval</code></p> </li> <li> <p><code>--nzb-subject</code></p> <ul> <li>This is what will be written inside the <code>.nzb</code> file created</li> <li>You do not want to obfuscate this for either private or public since this will only ever be accessible to someone who already has the <code>.nzb</code> file</li> <li>You can again use more of the built-in tokens to format this in a way we like</li> <li>I'll be using <code>[${filenum}/${files}] - \"${filename}\" yEnc (${part}/${parts}) ${filesize}</code> format, following the yenc standard</li> <li>This results in <code>[1/7] - &amp;quot;Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv&amp;quot; yEnc (1/483) 346,054,287</code></li> </ul> </li> <li> <p><code>--dump-failed-posts</code></p> <ul> <li>This option writes any failed posts to a user-defined directory</li> <li>You can then repost these failed posts as needed</li> </ul> </li> </ol>"},{"location":"archive/parpar-filepath-formats/","title":"ParPar filepath formats","text":"<p>Note</p> <p>This page covers the usage of the <code>--filepath-format</code> option in ParPar. You do not need to know this to use <code>juicenet</code>. I wrote this after testing all of the filepath formats to better understand them myself.</p> <p>Filepath format is what allows us to either discard paths for singular files or preserve complex folder structures such as those in BDMVs when uploading to Usenet without the need of RAR. PAR2 files can store the folder structure which can then be used by SABnzbd to reconstruct the folder structure from the PAR2 files completely eliminating the need to RAR them. What's wrong with RAR?</p> <p>ParPar's help text on <code>--filepath-format</code>:</p> <pre><code>  -f,  --filepath-format     How to format input file paths, can be either:\n                                 basename: discard paths\n                                 keep: retain full paths as specified\n                                 common: discard common parts of paths; falls\n                                         back to basename if there is no common\n                                         path\n                                 outrel: path computed relative to output\n                                 path: path computed relative to that specified\n                                       in `--filepath-base`\n                             Default is `common`, or `path` if `--filepath-base`\n                             is specified.\n  -B,  --filepath-base       The base path to use when computing paths when\n                             `--filepath-format=path` is used.\n                             Default is `.` (i.e. current working directory)\n</code></pre>"},{"location":"archive/parpar-filepath-formats/#filepath-formats","title":"Filepath Formats","text":"<p>I'll be using <code>[EAC][170215] Porter Robinson &amp; Madeon - SHELTER</code> BDMV as an example to better demonstrate what I'm talking about. This is located <code>D:\\topdir\\subdir</code>. These details are important so remember them.</p> <pre><code>[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\BACKUP\\CLIPINF\\00000.clpi\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\BACKUP\\CLIPINF\\00001.clpi\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\BACKUP\\CLIPINF\\00002.clpi\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\BACKUP\\CLIPINF\\00003.clpi\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\BACKUP\\MovieObject.bdmv\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\BACKUP\\PLAYLIST\\00000.mpls\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\BACKUP\\PLAYLIST\\00001.mpls\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\BACKUP\\PLAYLIST\\00002.mpls\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\BACKUP\\index.bdmv\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\CLIPINF\\00000.clpi\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\CLIPINF\\00001.clpi\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\CLIPINF\\00002.clpi\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\CLIPINF\\00003.clpi\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\MovieObject.bdmv\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\PLAYLIST\\00000.mpls\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\PLAYLIST\\00001.mpls\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\PLAYLIST\\00002.mpls\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\STREAM\\00000.m2ts\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\STREAM\\00001.m2ts\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\STREAM\\00003.m2ts\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\index.bdmv\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\CERTIFICATE\\BACKUP\\id.bdmv\n[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\CERTIFICATE\\id.bdmv\n</code></pre>"},{"location":"archive/parpar-filepath-formats/#-filepath-format-basename","title":"<code>--filepath-format basename</code>","text":"<ul> <li>Simply keeps the filename and discards all path.</li> <li>NOT affected by either <code>-o</code> or input path.</li> </ul> <p>Example:</p> <pre><code>parpar [args] --filepath-format basename -o \"[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\" \"[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\"\n</code></pre> <p>Result:</p> <pre><code>00000.1.clpi\n00000.1.mpls\n00000.clpi\n00000.m2ts\n00000.mpls\n00001.1.clpi\n00001.1.mpls\n00001.clpi\n00001.m2ts\n00001.mpls\n00002.1.clpi\n00002.1.mpls\n00002.clpi\n00002.mpls\n00003.1.clpi\n00003.clpi\n00003.m2ts\nMovieObject.1.bdmv\nMovieObject.bdmv\nid.1.bdmv\nid.bdmv\nindex.1.bdmv\nindex.bdmv\n</code></pre> <p>As you can see it simply discarded all paths and added numbers to duplicate filenames.</p>"},{"location":"archive/parpar-filepath-formats/#-filepath-format-keep","title":"<code>--filepath-format keep</code>","text":"<ul> <li>Stores the complete input path as passed to parpar.</li> <li>NOT affected by <code>-o</code> but affected by the input path as it'll keep whatever you pass.</li> </ul> <p>Example 1:</p> <pre><code>parpar [args] --filepath-format keep -o \"anything-goes-here\" \"[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\"\n</code></pre> <p>Result:</p> <pre><code>[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\BACKUP\\CLIPINF\\00000.clpi\n</code></pre> <p>Example 2:</p> <pre><code>parpar [args] --filepath-format keep -o \"anything-goes-here\" \"D:\\topdir\\subdir\\[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\BACKUP\\CLIPINF\\00000.clpi\"\n</code></pre> <p>Result:</p> <pre><code>D:\\topdir\\subdir\\[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\BACKUP\\CLIPINF\\00000.clpi\n</code></pre>"},{"location":"archive/parpar-filepath-formats/#-filepath-format-common","title":"<code>--filepath-format common</code>","text":"<ul> <li>Discards part of the path that's common across ALL the files.</li> <li>NOT affected by <code>-o</code> but affected by the input path</li> </ul> <p>Example:</p> <pre><code>parpar [args] --filepath-format common -o \"anything-goes-here\" \"[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\"\n</code></pre> <p>Result:</p> <pre><code>BDMV\\BACKUP\\CLIPINF\\00000.clpi\n</code></pre> <p>Explanation: Look at the BDMV directory structure provided at the top and see how <code>[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\</code> is common across all the files. This common part gets discarded. This is the DEFAULT behavior.</p>"},{"location":"archive/parpar-filepath-formats/#-filepath-format-outrel","title":"<code>--filepath-format outrel</code>","text":"<ul> <li>Stores path relative to the output (<code>-o</code>)</li> <li>NOT affected by the input path as all path is calculated relative to whatever you pass in <code>-o</code></li> </ul> <p>Example 1:</p> <pre><code>parpar [args] --filepath-format outrel -o \"[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\" \"D:\\topdir\\subdir\\[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\"\n</code></pre> <p>Result:</p> <pre><code>[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\BACKUP\\CLIPINF\\00000.clpi\n</code></pre> <p>Explanation: I passed <code>\"[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\"</code> as my output path which means it's in the current working directory and parpar will store the path relative to my output path. This is inclusive, which means the output directory will be included.</p> <p>Example 2:</p> <pre><code>parpar [args] --filepath-format outrel -o \"D:\\topdir\\subdir\\[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\" \"D:\\topdir\\subdir\\[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\"\n</code></pre> <p>Result:</p> <pre><code>[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\BACKUP\\CLIPINF\\00000.clpi\n</code></pre> <p>Explanation: I passed <code>\"D:\\topdir\\subdir\\[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\"</code> as my output path. This is an absolute path and in this case parpar will store the path relative to final directory in the path which is <code>[EAC][170215] Porter Robinson &amp; Madeon - SHELTER</code> located in <code>D:\\topdir\\subdir</code>. Again this is inclusive, which means the final directory will be included. The results end up being identical to Example 1.</p> <p>Example 3:</p> <pre><code>parpar [args] --filepath-format outrel -o \"C:\\test\\[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\" \"D:\\topdir\\subdir\\[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\"\n</code></pre> <p>Result:</p> <pre><code>D:\\topdir\\subdir\\[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\BACKUP\\CLIPINF\\00000.clpi\n</code></pre> <p>Explanation: In this case output directory is in a different drive and so there's no relative path possible to our files, so parpar stores the absolute path when there's no possible relative path.</p>"},{"location":"archive/parpar-filepath-formats/#-filepath-format-path","title":"<code>--filepath-format path</code>","text":"<ul> <li>Stores input path relative to the path passed to <code>--filepath-base</code>.</li> <li>NOT affected by <code>-o</code></li> </ul> <p>My current working directory: <code>D:\\topdir</code></p> <p>Example:</p> <pre><code>parpar [args] --filepath-base \"D:\\topdir\\subdir\" --filepath-format path -o \"arbitrary\\path\\[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\" \"D:\\topdir\\subdir\\[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\"\n</code></pre> <p>Result:</p> <pre><code>[EAC][170215] Porter Robinson &amp; Madeon - SHELTER\\BDROM\\PORTER_ROBINSON_MADEON_SHELTER\\BDMV\\BACKUP\\CLIPINF\\00000.clpi\n</code></pre> <p>Explanation: As you can see the path being stored here starts from <code>[EAC][170215] Porter Robinson &amp; Madeon - SHELTER</code> because my <code>filepath-base</code> was <code>D:\\topdir\\subdir</code> which was used to calculate the relative path from base to input and my working directory got ignored entirely. Just like <code>outrel</code>, when there's no relative path to be found, it'll store the absolute path.</p>"},{"location":"archive/uploading-to-usenet/","title":"Uploading to Usenet","text":"<p>Note</p> <p>This page covers the process of manually uploading a file to Usenet. You do not need to know this to use the <code>juicenet</code>. This is essentially what it does. This is what I initially wrote when I was first figuring this stuff out and seeing how there's no good guide out there, I've decided to keep it for anyone else trying to figure this stuff out. It's not a good guide because it was never meant to be one, but it's better than nothing.</p>"},{"location":"archive/uploading-to-usenet/#prerequisites","title":"Prerequisites","text":""},{"location":"archive/uploading-to-usenet/#linux","title":"Linux","text":"<ol> <li> <p>Install <code>nvm</code></p> <pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.4/install.sh | bash\n</code></pre> </li> <li> <p>Install <code>node</code></p> <pre><code>nvm install node\n</code></pre> </li> <li> <p>Install <code>yencode</code></p> <pre><code>npm install yencode\n</code></pre> </li> <li> <p>Install <code>Nyuu</code></p> <pre><code>npm install -g nyuu --production --unsafe-perm\n</code></pre> </li> <li> <p>Install <code>ParPar</code></p> <pre><code>npm install -g @animetosho/parpar\n</code></pre> </li> </ol>"},{"location":"archive/uploading-to-usenet/#windows","title":"Windows","text":"<p>On Windows, you simply need to grab the following two pre-built binaries:</p> <ol> <li>Nyuu</li> <li>ParPar</li> </ol>"},{"location":"archive/uploading-to-usenet/#getting-started","title":"Getting Started","text":"<p>Let's assume I want to upload this file:</p> <pre><code>Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv\n</code></pre>"},{"location":"archive/uploading-to-usenet/#parpar","title":"Parpar","text":"<p>Parpar is a tool to create <code>PAR2</code> files. <code>PAR2</code> files are very important because they are parity data that can be used to recover missing or damaged files. This can be done easily with the following command:</p> <pre><code>parpar -s700k --slice-size-multiple=700K --max-input-slices=4000 -r1n*1.2 -R \\\n--filepath-format basename \\\n-o \"path/to/Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv\" \\\n\"path/to/Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv\"\n</code></pre> <p>Note</p> <p>You must generate PAR2 files for every single file you upload. Uploading stuff to Usenet without <code>PAR2</code> files is as good as not uploading them.</p> <p>Apart from being parity data, <code>PAR2</code> files also store the path of the file. This then allows downloaders like SABnzbd to reconstruct folder structures. This is really handy for stuff like <code>BDMVs</code> where the folder structure is important.</p> <p>In this case, I'm uploading a singular episode where paths don't matter so I'll use <code>--filepath-format basename</code> which discards all the paths and only keeps the filename.</p> <p>This means that:</p> <p><pre><code>path/to/Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv\n</code></pre> will become <pre><code>Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv\n</code></pre></p> <p><code>--filepath-format</code> has more options and might change depending on your use case. You can read more about it here. You can read what the other options do here but they'll mostly remain constant.</p> <p>After this, you will now have <code>.par2</code> files like this:</p> <pre><code>.\n\u251c\u2500\u2500 Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv\n\u251c\u2500\u2500 Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv.par2\n\u251c\u2500\u2500 Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv.vol00+01.par2\n\u251c\u2500\u2500 Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv.vol01+02.par2\n\u251c\u2500\u2500 Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv.vol03+04.par2\n\u251c\u2500\u2500 Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv.vol07+08.par2\n\u2514\u2500\u2500 Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv.vol15+16.par2\n</code></pre>"},{"location":"archive/uploading-to-usenet/#nyuu","title":"Nyuu","text":"<p>Now that we have the our video file with it's corresponding <code>.par2</code> files, we have to upload it. The upload command will look something like this:</p> <pre><code>nyuu -C \"/path/to/config.json\" \\\n-o \"path/to/Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.nzb\" \\\n\"path/to/Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv\" \\\n\"path/to/Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv.par2\" \\\n\"path/to/Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv.vol00+01.par2\" \\\n\"path/to/Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv.vol01+02.par2\" \\\n\"path/to/Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv.vol03+04.par2\" \\\n\"path/to/Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv.vol07+08.par2\" \\\n\"path/to/Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv.vol15+16.par2\"\n</code></pre> <p>As you can see, you have to explicitly pass each file and it's <code>.par2</code> files to Nyuu and tell it to make a single output <code>nzb</code> with <code>-o \"path/to/Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.nzb\"</code>. Not really ideal, considering doing this for every episode would be tedious.</p> <p>Alternatively, you can move the files into a folder as such:</p> <pre><code>Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group/\n\u251c\u2500\u2500 Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv\n\u251c\u2500\u2500 Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv.par2\n\u251c\u2500\u2500 Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv.vol00+01.par2\n\u251c\u2500\u2500 Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv.vol01+02.par2\n\u251c\u2500\u2500 Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv.vol03+04.par2\n\u251c\u2500\u2500 Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv.vol07+08.par2\n\u2514\u2500\u2500 Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.mkv.vol15+16.par2\n</code></pre> <p>And, then uploading gets much simpler because you can just pass the folder to Nyuu and it'll make a single nzb out of them:</p> <pre><code>nyuu -C \"/path/to/config.json\" \\\n-o \"path/to/Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group.nzb\" \\\n\"path/to/Show.S01E01.BluRay.1080p.FLAC2.0.H.265-Group/\"\n</code></pre> <p>Either of the above commands will start uploading our video and <code>.par2</code> files and output the <code>.nzb</code> file once it's done but neither of them are ideal. Explicitly specifying each file is tedious and moving files into a folder might break other stuff (e.g. if you're seeding the file in a torrent client).</p> <p>During the above upload process, your files are uploaded in tiny chunks (<code>~700KiB</code>) called <code>raw articles</code>. Think of it as <code>pieces</code> in torrents. Now some of these <code>raw articles</code> can fail to upload for various reasons. Nyuu will put all the failed <code>raw articles</code> in the folder defined by <code>--dump-failed-posts</code>. You should check this folder and repost the failed <code>raw articles</code> later which can be done with the command below:</p> <pre><code>nyuu -C \"/path/to/config.json\" \\\n--log-time --skip-errors all \\\n--delete-raw-posts \\\n--input-raw-posts \"/path/to/your/dump/as/defined/in/config\"\n</code></pre>"},{"location":"installation/docker/","title":"Docker Installation","text":"<p><code>juicenet</code> is available as a docker image on both Docker Hub and ghcr.io.</p> Docker Hubghcr <pre><code>docker pull ravencentric/juicenet-cli\n</code></pre> <pre><code>docker pull ghcr.io/ravencentric/juicenet-cli\n</code></pre>"},{"location":"installation/docker/#docker-composeyml","title":"<code>docker-compose.yml</code>","text":"<pre><code>---\nversion: \"2.1\"\nservices:\n  juicenet:\n    image: ravencentric/juicenet-cli:latest\n    container_name: juicenet\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=Etc/UTC\n    volumes:\n      - host/path/to/config/nyuu.docker.private.json:/config/nyuu.docker.private.json\n      - host/path/to/config/nyuu.docker.public.json:/config/nyuu.docker.public.json\n      - host/path/to/data/nzbs:/data/nzbs\n      - host/path/to/data/appdata:/data/appdata\n      - host/path/to/data/raw:/data/raw\n      - host/path/to/media:/media\n</code></pre> <p>Note</p> <p>The value of <code>dump-failed-posts</code> in your nyuu config must match the compose file, i.e, it must be set to <code>/data/raw</code></p> nyuu-config.json<pre><code>\"dump-failed-posts\":  \"/data/raw\"\n</code></pre> <p>Note</p> <p>To keep things simple, this image requires a secondary config. If you aren't planning to use a secondary config, you can simply reuse the primary config again.</p>"},{"location":"installation/docker/#usage","title":"Usage","text":"<p>After you're done copying the <code>docker-compose.yml</code> and editing the host paths to match yours, you can run <code>juicenet</code> with the following command:</p> <pre><code>docker compose -f \"path/to/docker-compose.yml\" run juicenet --help\n</code></pre>"},{"location":"installation/docker/#available-tags","title":"Available Tags","text":"Tag Description <code>latest</code> Latest stable release (default) <code>main</code> Latest commit in the <code>main</code> branch <code>X.Y.Z</code> Specific release, for example, <code>0.30.0</code> <code>X.Y</code> Latest release in the specified major and minor version <code>sha-ed9e6ff</code> Specific git commit identified by its unique short SHA <p>Note</p> <p>Docker images are only available for <code>v0.30.0</code>+</p>"},{"location":"installation/local/","title":"Local Installation","text":""},{"location":"installation/local/#prerequisites","title":"Prerequisites","text":"<p>Since <code>juicenet</code> uses Nyuu and ParPar, you need to have these installed. Follow the instructions below to install them.</p> With Executables (Windows)With NPM (Windows)With NPM (Linux) <ol> <li> <p><code>ParPar &gt;= 0.4.2</code> - Grab the executable from here</p> </li> <li> <p><code>Nyuu &gt;= 0.4.2</code> - Grab the executable from here</p> </li> </ol> <ol> <li> <p>Install <code>Visual C++ Build Environment</code></p> </li> <li> <p>Install <code>nvm</code></p> </li> <li> <p>Install <code>node</code></p> <pre><code>nvm install node\n</code></pre> </li> <li> <p>Install <code>yencode</code></p> <pre><code>npm install yencode\n</code></pre> </li> <li> <p>Install <code>Nyuu</code></p> <pre><code>npm install -g nyuu --production --unsafe-perm\n</code></pre> </li> <li> <p>Install <code>ParPar</code></p> <pre><code>npm install -g @animetosho/parpar\n</code></pre> </li> </ol> <ol> <li> <p>Install <code>nvm</code></p> <pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash\n</code></pre> </li> <li> <p>Install <code>node</code></p> <pre><code>nvm install node\n</code></pre> </li> <li> <p>Install <code>yencode</code></p> <pre><code>npm install yencode\n</code></pre> </li> <li> <p>Install <code>Nyuu</code></p> <pre><code>npm install -g nyuu --production --unsafe-perm\n</code></pre> </li> <li> <p>Install <code>ParPar</code></p> <pre><code>npm install -g @animetosho/parpar\n</code></pre> </li> </ol>"},{"location":"installation/local/#installing-juicenet","title":"Installing juicenet","text":"<p><code>juicenet</code> currently supports <code>Python &gt;= 3.9</code></p> <ol> <li> <p>With pipx (recommended):</p> <pre><code>pipx install juicenet-cli\n</code></pre> </li> <li> <p>With pip:</p> <pre><code>pip install juicenet-cli\n</code></pre> </li> <li> <p>From git with poetry:</p> <p>Note</p> <p>The <code>main</code> branch is not stable and maybe broken. Use this method if you know what you're doing.</p> <p>Stable (mostly) builds can be found in releases or PyPI.</p> <pre><code>git clone https://github.com/Ravencentric/juicenet-cli.git\n</code></pre> <pre><code>cd juicenet-cli\n</code></pre> <p>Run:</p> <pre><code>poetry install\n</code></pre> <pre><code>poetry run juicenet --help\n</code></pre> <p>Build:</p> <pre><code>poetry build\n</code></pre> </li> </ol>"}]}